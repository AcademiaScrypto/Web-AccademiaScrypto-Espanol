# Creaci칩n de DAO - Nuevos miembros

::: warning
- Esta unidad est치 actualizada para Scrypto version 0.4 o mayor -> [Instrucciones actualizaci칩n](/scrypto/instalacion/actualizacion.md)
:::

::: tip 游닠
- [Pronto Video Demostraci칩n]()
- [C칩digo GitHub](https://github.com/AcademiaScrypto/Web-AccademiaScrypto-Espanol/blob/master/scrypto/codigo/unidad7.rs)
:::

Durante las siguientes unidades vamos a crear una DAO (Organizaci칩n aut칩noma descentralizada), que sin duda durante 2022 est치n llamadas a ser tendencia y seguro que han llegad1o para quedarse entre nosotros. Aprender a crear DAOs puede tener un gran potencial. 춰Comencemos!

### An치lisis
**Problema:** Deseamos crear una DAO donde los afiliado van a poder darse de alta sin ning칰n tipo de autorizaci칩n. 

**An치lisis:** Al pedirnos una DAO ya estamos dando por supuesto que vamos a crear una dApp. Para ello vamos a crear un *Componente*, dentro de la red de Radix, que nos va a permitir dar un *no fungible* a cada nuevo afiliado para que pueda demostrar su pertenencia y en un futuro identificarse dentro de la DAO.

### Dise침o:
![Diagramas](./img/diagramas_unidad6.png)

Dos diagramas: uno para la funci칩n constructora y el segundo para la primera funcionalidad que nos solicitan y es la de poder registrarse, cualquiera, al DAO retornando un *no fungible* como acreditaci칩n de su pertenencia al DAO. *(Nota: en cuanto m치s lenguaje m치s natural expresemos en estos diagramas mejor, yo a veces peco de incluir t칠rminos t칠cnicos propios del lenguaje o plataforma que utilice)*

### Programaci칩n:

### NFT Estructura Datos:

Como ya vimos en la [unidad anterior](/scrypto/programacion/unidad5.md) *Scrypto* pone a disposici칩n una macro para poder crear una estructura de datos, mutables e inmutables, que luego podremos incorporar a nuestros *no fungible*:

```rust
#[derive(NonFungibleData)]
pub struct DatosAfiliado {
    nombre: String
}
```

En este caso hemos llamado a la estructura: *DatosAfiliado* (recuerda, es algo arbitrario) y de momento solo le hemos implementado un dato de tipo *String* (Cadena de caracteres) para guardar el nombre del afiliado (ser치 un dato inmutable).

### La estructura:

Vamos a necesitar crear un contador para guardar el n칰mero de afiliado, lo normal es que esta vez sea un n칰mero legible y no uno aleatorio, y que a su vez nos har치 de identificador del NFT. Para poder utilizar como identificadores [*NonFungibleId*](https://radixdlt.github.io/radixdlt-scrypto/scrypto/engine/types/struct.NonFungibleId.html#) tenemos que crear un dato de tipo u32.

::: tip
|DATA TYPE   |MIN    |MAX |
| ---------- |-------|----|
|u8	         |0      |255 |
|u16         |0      |65535 |
|u32         |0      |4294967295 |
|u64	     |0      |18446744073709551615 |
|u128        |0      |340282366920938463463374607431768211455 |
:::

Luego necesitaremos guardar la direcci칩n del recurso no fungible que queremos dar a cada afiliado, est치 ser치 de tipo ResourceAddress.

::: tip
- Gracias a la direcci칩n del recurso, ResourceAddress, podemos determinas si el no fungible que alguien nos presente es el que esper치bamos o no. 
:::

Y de momento solo nos quedar칤a a침adir un contenedor permanente (Vault) para guardar una *insignia* (badge) que autorice al Componente para mintear nuevos *no fungibles*. En este caso la insignia con autorizaci칩n para acu침ar se guardara en el propio componente para que la utilice cuando sea necesario. 

```rust
struct Sistema_afiliacion {
        badge: Vault,
        direccion_nft: ResourceAddress,
        num_afiliado: u32
}
```

### Funci칩n constructora *instantiate_dao*

1. Primero vamos a crear la autorizaci칩n para crear el *no fungible*:
```rust
let badge = ResourceBuilder::new_fungible()
                .metadata("name", "Autorizaci칩n mintear nuevos NFT")
                .divisibility(DIVISIBILITY_NONE)
                .initial_supply(1);
```
Creamos un recurso con, *ResourceBuilder*, de tipo fungible. El *name* que lo identifique, es especialmente interesante para poder identificarlo cuando realizamos *resim show*. Especificamos que no sera divisible. Y finalmente un suministro inicial de 1.

::: tip
Llamar .divisibility al crear un nuevo recurso es opcional. Si no se llama, la divisibilidad del recurso se establece en el valor predeterminado de 18.
:::

2. Creamos la definici칩n *no fungible* que vamos a entregar a cada persona que se registre en el DAO:

```rust
let afiliado = ResourceBuilder::new_non_fungible()
    .metadata("name", "Afiliado DAO")
    .mintable(rule!(require(badge.resource_address())), LOCKED)
    .no_initial_supply();
```
En este caso el recurso ser치 de tipo no fungible, *new_non_fungible*, y tiene varios m칠todos que pueden definir sus caracter칤sticas:

-  *.metadata*: Permite dar nombre al recurso.

Seguidamente a침adiremos al recurso una regla de autorizaci칩n para poder acu침ar nuevos *no fungibles*:  

```rust
.mintable(rule!(require(badge.resource_address())), LOCKED)
```
En este caso la regla solo permite a la insignia (badge) que hemos acu침ado antes y que hemos guardado en el propio Componente. E incluimos el par치metro *LOCKED* que impide que sea modificado la regla de acu침aci칩n para este recurso. 

Finalmente, *.no_initial_supply()*, que indica que no vamos a crear inicialmente ning칰n suministro.

3. Pasamos a la estructura del componente:
    - La insignia (badge) que hemos creado para autorizar acu침ar nuevos NFT, como tenemos el recurso (supply 1) en una variable, *badge*, podemos utilizar el comando *with_bucket* para crea una b칩veda vac칤a permanente y llenarla con un dep칩sito inicial de recursos contenidos en un bucket.
    - Pasamos la definici칩n del recurso de NFT al componente.
    - Inicializamos la variable *num_afiliado* a cero. 

```rust
Self {
        badge: Vault::with_bucket(badge),
        direccion_nft: afiliado,
        num_afiliado: 0
    }
    .instantiate()
    .globalize()
```

### M칠todo *afiliarse_dao*

Este m칠todo permite poder registrarse en la DAO como afiliado sin ning칰n tipo de autorizaci칩n para ello, de forma totalmente libre. Solo ha de introducir un nombre de tipo string. 

El m칠todo al ejecutarse toma el nombre que se le ha indicado, a침ade 1 al num_afiliado para generar el nuevo n칰mero y finalmente acu침a el NFT con esos dos datos: el numero afiliado como identificador y el nombre como dato inmutable. Finalmente el m칠todo devuelve un contenedor temporal con la acreditaci칩n de afiliado al DAO en forma de NFT a la cuenta que ha desencadenado este m칠todo. 


```rust
pub fn afiliarse_dao(&mut self, nombre: String) -> Bucket {
    self.num_afiliado += 1;

    self.badge.authorize(||{
        let resource_manager = borrow_resource_manager!(self.direccion_nft);
            resource_manager.mint_non_fungible(
                &NonFungibleId::from_u32(self.num_afiliado),
                DatosAfiliado {
                    nombre: nombre
                }
            )
    })
}
```

Pasamos la autorizaci칩n para acu침ar mediante el contenedor permanente *badge* de la siguiente manera:
```rust
self.badge.authorize(|| {
}
```
Tomamos el recurso ResourceManager a trav칠s del la siguiente macro *borrow_resource_manager!* a la que pasamos como par치metro la direcci칩n del recurso que queremos utilizar *ResourceAddress* que hemos guardado en la variable *direccion_nft*.

```rust
let resource_manager = borrow_resource_manager!(self.direccion_nft);
```
::: tip
**ResourceManager** nos permite realizar operaciones como acu침ar tokens adicionales, grabar tokens, actualizar metadatos, etc.
:::

Una vez tenemos el ResourceManager del recurso que queremos acu침ar utilizamos el m칠todo *mint_non_fungible* al que pasamos los datos: identificador y los datos de la estructura que declaramos como *DatosAfiliado* que contiene el nombre del afiliado.

El tipo NonFungibleId nos permite dar al *no fungible* un identificador 칰nico. En este caso, el identificador ser치 el n칰mero de afiliado que hemos generado y guardo en la variable *num_afiliado.

Como es un tipo u32 lo convertimos a *NonFungibleId* con el m칠todo *from_u32* que recibe como par치metro el n칰mero de afiliado.

```rust
&NonFungibleId::from_u32(self.num_afiliado)
```
Finalmente pasamos los datos del no fungible, en este caso solo el nombre que previamente pasamos como entrada al m칠todo. 

```rust
DatosAfiliado {
    nombre: nombre
}
```

### C칩digo completo:

```rust
use scrypto::prelude::*;

#[derive(NonFungibleData)]
pub struct DatosAfiliado {
    nombre: String
}

blueprint! {
    struct Afiliacion {
        badge: Vault,
        direccion_nft: ResourceAddress,
        num_afiliado: u32
    }

    impl Afiliacion {

        pub fn instantiate_dao() -> ComponentAddress {
            
            let badge = ResourceBuilder::new_fungible()
                .metadata("name", "Autorizaci칩n mintear nuevos NFT")
                .divisibility(DIVISIBILITY_NONE)
                .initial_supply(1);
                
            let afiliado = ResourceBuilder::new_non_fungible()
                .metadata("name", "Afiliado DAO")
                .mintable(rule!(require(badge.resource_address())), LOCKED)
                .no_initial_supply();

            Self {
                badge: Vault::with_bucket(badge),
                direccion_nft: afiliado,
                num_afiliado: 0
            }
            .instantiate()
            .globalize()
        }

        pub fn afiliarse_dao(&mut self, nombre: String) -> Bucket {
            self.num_afiliado += 1;
        
            self.badge.authorize(||{
                let resource_manager = borrow_resource_manager!(self.direccion_nft);
                    resource_manager.mint_non_fungible(
                        &NonFungibleId::from_u32(self.num_afiliado),
                        DatosAfiliado {
                            nombre: nombre
                        }
                    )
            })
        }
    }
}
```
### Compilaci칩n y ejecuci칩n

A estas alturas seguro que ya sabes publicar el *package*, instanciar el *Component* y llamar a los m칠todos pasando un par치metro.

::: warning Recuerda
- Antes de empezar siempre es recomendable limpiar el simulador con el comando:
```
resim reset
```
:::

::: details Solo para aquellos (tipo Emilio 游뱕) que no quieren pensar!!!
1. Limpiar el simulador
```rust
resim reset
```
2. Crear un Package
```
scrypto new-package dao
```
3. Crear una cuenta (recuerda copiar la direcci칩n de los XRD de tu cuenta)
```rust
resim new-account
set acct [Address de la cuenta que acabamos de crear]
```
4. Copiar o escribir el c칩digo (recuerda guardar ctrl + s)
- Recuerda guardar el c칩digo de este ejercicio dentro del archivo lib.rs que has creado en la carpeta *\radixdlt-scrypto\dao\src\lib.rs*
5. Publicar y guardamos la direcci칩n del Package
```rust
resim publish .
set pack [New Package Reference]
```
6. Instanciar componente (recuerda que en este caso hay que a침adir el argumento del precio) y guardar la direcci칩n del componente.
```rust
resim call-function $pack Afiliacion instantiate_dao
set comp [direcci칩n del componente]
```
7. Probar m칠todo *afiliarse_dao*
```rust
resim call-method $comp afiliarse_dao "Antonio Bitcoin"
// Ojo que cuando pasamos un dato de tipo string y tiene mas de una palabra debemos entrecomillarlo.
```
8. Comprobar el nft de afiliado
```rust
resim show $acct
```
:::

::: danger Importante:
- Soy muy consciente de que hay muchas que no has entendido, 춰TRANQUILO!, no te rindas, las entender치s... 游땔
:::